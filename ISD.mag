// Declaration of code variables and instances
q := 2;
m := 7;
n := 7;
SetSeed(42);
F<a> := GF(q,m);
SetPowerPrinting(F, false);
R<z> := PolynomialRing(F);
k:=3;
d := m - k +1;
// generation of the parity check matrix n x (m-k)



function ISD_GB(y,H,r)
	Cdual := LinearCode(H);
	C := Dual(Cdual) + LinearCode(y);

	// declaration of the variables
	s_max := (m-r)*(r-1);
	c2_min := s_max + 1;
	c2_max := s_max + r*(n-k-1);
	c1_min := c2_max + 1;
	c1_max := c2_max + r*k;
	R<[x]>:=PolynomialRing(F,c1_max);


	// construction of FF
	// using OJ modelling

	v := Vector([a^i : i in [0..m-1]]);
	/* S is mxr with form:
	|  I_r   |
	| 0 | S' |
	*/
	S := ZeroMatrix(R,m,r);
	InsertBlock(~S,IdentityMatrix(R,r),1,1);
	// now s_i,j will be x[1],...,x[(m-r)*(r-1)] 
	S_x := Matrix(R,m-r,r-1,[ x[i] : i in [1..s_max]]);
	InsertBlock(~S,S_x,r+1,2);

	RR := Submatrix(ChangeRing(GeneratorMatrix(C),R),[1..k+1],[k+2..n]);
	
	CC2 := Matrix(R,r,n-k-1,[ x[i] : i in [c2_min..c2_max]]);
	CC1_x := Matrix(R,r,k,[ x[i] : i in [c1_min..c1_max]]);
	CC1 := ZeroMatrix(R,r,k+1);
	InsertBlock(~CC1,CC1_x,1,2);
	CC1[1,1] := 1;

	Eq := v*S*(CC2 - CC1*RR);
	FF := Eltseq(Eq);

	// construction of FF_q
	// field equations
	FFq := [ x[i]^q - x[i] : i in [1..c1_max]];

	SetVerbose("Groebner",1); 
	GB := GroebnerBasis(FF cat FFq);
	GB;

	ev := [F!(GB[i]- x[i]) : i in [1..c1_max]];
	S := ZeroMatrix(F,m,r);
	InsertBlock(~S,IdentityMatrix(F,r),1,1);
	S_e := Matrix(F,m-r,r-1,ev[1..s_max]);
	InsertBlock(~S,S_e,r+1,2);
	
	CC2 := Matrix(F,r,n-k-1,ev[c2_min..c2_max]);
	CC1_e := Matrix(F,r,k,ev[c1_min..c1_max]);
	CC1 := ZeroMatrix(F,r,k+1);
	InsertBlock(~CC1,CC1_e,1,2);
	CC1[1,1] := 1;
	CC := ZeroMatrix(F,r,n);
	InsertBlock(~CC,CC1,1,1);
	InsertBlock(~CC,CC2,1,k+2);

	E := v*S*(CC);
	ls := E*Transpose(H);
	s := y*Transpose(H);
	E := E*DotProduct(s,s)/DotProduct(ls,s);

	return E;
end function;

base := [ a^i : i in [0..n-1]];
H := Matrix(F, [ [ mu^(q^j) : mu in base] : j in [k..n-1]]);
// generation of the generator matrix n x k
G := ParityCheckMatrix(LinearCode(H));
c := Vector([Random(F) : _ in [1..k]])*G;

// Problem: we need S with the first rxr block inv
c[1] +:= 1;
c[2] +:= a;
//c[3] +:= a^2 + a;

"Output massey:";
e := ISD_GB(c,H,2);
e;//, wRank(e);
"\n";
